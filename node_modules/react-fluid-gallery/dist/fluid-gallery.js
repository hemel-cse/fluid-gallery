"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var THREE = _interopRequireWildcard(require("three"));

var _isVideo = _interopRequireDefault(require("is-video"));

var _frag = _interopRequireDefault(require("./frag"));

var _vert = _interopRequireDefault(require("./vert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var FluidGallery =
/*#__PURE__*/
function () {
  function FluidGallery(opts) {
    var _this = this;

    _classCallCheck(this, FluidGallery);

    _defineProperty(this, "_initTexture", function (src) {
      if ((0, _isVideo.default)(src)) {
        var video = document.createElement('video');
        video.muted = true;
        video.loop = true;
        video.autoplay = true;
        var texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.maxFilter = THREE.LinearFilter;
        video.addEventListener('load', function () {
          return _this._updateTextureOnResize(texture);
        });
        video.addEventListener('loadedmetadata', function () {
          return _this._updateTextureOnResize(texture);
        });
        video.src = src;
        video.load();
        var play = video.play();

        if (play) {
          play.catch(function () {
            return undefined;
          });
        }

        return texture;
      } else {
        var _texture = _this._textureLoader.load(src, _this._updateTextureOnResize);

        return _texture;
      }
    });

    _defineProperty(this, "_updateTextureOnResize", function (texture) {// TODO: changing texture wrapS/wrapT and UV matrix only works with textures
      // that are sizeed power of two

      /*
      let texWidth
      let texHeight
       if (texture.image) {
        texWidth = texture.image.naturalWidth || texture.image.videoWidth
        texHeight = texture.image.naturalHeight || texture.image.videoHeight
      }
       // console.log('_updateTextureOnResize', texture, { texWidth, texHeight })
       if (texWidth > 0 && texHeight > 0) {
        const {
          width,
          height
        } = this._canvas
         texture.wrapS = THREE.ClampToEdgeWrapping
        texture.wrapT = THREE.ClampToEdgeWrapping
         // const t = rectCover(this._canvas, { width: texWidth, height: texHeight })
        // console.log(t)
         // texture.offset.set(t[0] / width, t[1] / height)
        // texture.repeat.set(4, 4)
         // const repeatX = width * texHeight / (height * texWidth)
        // const repeatY = 1
        // texture.repeat.set(repeatX, repeatY)
        // texture.offset.x = (repeatX - 1) / 2 * -1
         texture.needsUpdate = true
        console.log(texture)
      }
      */
    });

    _defineProperty(this, "onScroll", function (event) {
      _this._speed += event.deltaY * 0.0002;
    });

    var canvas = opts.canvas,
        slides = opts.slides,
        _opts$current = opts.current,
        current = _opts$current === void 0 ? 0 : _opts$current;
    var width = canvas.width,
        height = canvas.height; // TODO: why is this necessary on safari with three.js?

    if (window.ImageBitmap === undefined) {
      window.ImageBitmap = function () {};
    }

    this._canvas = canvas;
    this._textureLoader = new THREE.TextureLoader();
    this._textures = slides.map(this._initTexture);
    this._time = 0;
    this._speed = 0;
    this._position = current;
    this._renderer = new THREE.WebGLRenderer({
      canvas: canvas
    });
    this._camera = new THREE.PerspectiveCamera(70, width / height, 0.001, 100);

    this._camera.position.set(0, 0, 1);

    this._material = new THREE.ShaderMaterial({
      side: THREE.DoubleSide,
      vertexShader: _vert.default,
      fragmentShader: _frag.default,
      uniforms: {
        time: {
          type: 'f',
          value: this._time
        },
        pixels: {
          type: 'v2',
          value: new THREE.Vector2(width, height)
        },
        accel: {
          type: 'v2',
          value: new THREE.Vector2(0.5, 2)
        },
        progress: {
          type: 'f',
          value: 0
        },
        uvRate1: {
          value: new THREE.Vector2(1, 1)
        },
        texture1: {
          value: this._textures[this.currentSlideIndex]
        },
        texture2: {
          value: this._textures[this.nextSlideIndex]
        }
      }
    });
    this._plane = new THREE.Mesh(new THREE.PlaneGeometry(1, 1, 1, 1), this._material);
    this._scene = new THREE.Scene();
    this._scene.background = new THREE.Color(0x111111);

    this._scene.add(this._plane);

    this.resize();
  }

  _createClass(FluidGallery, [{
    key: "resize",
    value: function resize() {
      var _this$_canvas = this._canvas,
          width = _this$_canvas.width,
          height = _this$_canvas.height;

      this._renderer.setSize(width, height);

      this._camera.aspect = width / height;
      this._material.uniforms.uvRate1.value.y = height / width;
      var dist = this._camera.position.z - this._plane.position.z;
      this._camera.fov = 2 * (180 / Math.PI) * Math.atan(1.0 / (2 * dist));
      this._plane.scale.x = width / height;

      this._camera.updateProjectionMatrix();

      this._textures.forEach(this._updateTextureOnResize);
    }
  }, {
    key: "update",
    value: function update() {
      this._time += 0.05;
      this._material.uniforms.time.value = this._time;
      this._position += this._speed;
      this._speed *= 0.7;
      var n = this._textures.length;
      var posI = Math.round(this._position);
      var diff = posI - this._position;
      this._position += diff * 0.035;

      if (Math.abs(posI - this._position) < 0.001) {
        this._position = posI;
      }

      if (this._position < 0) {
        this._position += n;
      }

      this._material.uniforms.progress.value = this._position;
      var currentSlide = this.currentSlideIndex;
      var nextSlide = this.nextSlideIndex;
      this._material.uniforms.texture1.value = this._textures[currentSlide];
      this._material.uniforms.texture2.value = this._textures[nextSlide]; // console.log({ currentSlide, nextSlide, position: this._position })
    }
  }, {
    key: "render",
    value: function render() {
      this._renderer.render(this._scene, this._camera);
    }
  }, {
    key: "currentSlideIndex",
    get: function get() {
      var n = this._textures.length;
      return (Math.floor(this._position) + n) % n;
    }
  }, {
    key: "nextSlideIndex",
    get: function get() {
      var n = this._textures.length;
      return (this.currentSlideIndex + 1) % n;
    }
  }]);

  return FluidGallery;
}();

exports.default = FluidGallery;
//# sourceMappingURL=fluid-gallery.js.map